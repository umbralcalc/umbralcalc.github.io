<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="description" content="umbralcalculations - Visual explorations in computation, science and creative writing" />
  <meta name="keywords" content="computation, science, creative writing, simulation, data" />
  
  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="../assets/umbralcalculations-logo.svg">
  <link rel="icon" type="image/x-icon" href="../assets/favicon.ico">
  <link rel="apple-touch-icon" href="../assets/umbralcalculations-logo.svg">
  
  <title>The building blocks of simulations</title>
  
  <!-- Fonts -->
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Merriweather:wght@300;400;700&family=Open+Sans:wght@300;400;600&display=swap');
  </style>
  
  <!-- Prism.js for syntax highlighting -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-vs.min.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-go.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-shell-session.min.js"></script>
  
  <!-- Custom CSS -->
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Open Sans', sans-serif;
      line-height: 1.6;
      color: #333;
      background: #fafafa;
      padding: 0;
      margin: 0;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 2rem;
      background: #fff;
      min-height: 100vh;
    }

    nav {
      margin-bottom: 3rem;
      padding-bottom: 1.5rem;
      border-bottom: 2px solid #e0e0e0;
      white-space: nowrap;
    }

    nav a {
      color: #2c3e50;
      text-decoration: none;
      font-weight: 600;
      margin-right: 2rem;
      transition: color 0.3s;
      font-size: 1.1rem;
      display: inline-block;
    }

    nav a:hover {
      color: #b0447aff;
      text-decoration: none;
    }

    /* Typography */
    h1, h2, h3, h4, h5, h6 {
      font-family: 'Merriweather', serif;
      color: #1a1a1a;
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      line-height: 1.3;
    }

    h1 {
      font-size: 2rem;
      color: #1a1a1a;
      margin-bottom: 0.5rem;
      border-bottom: 3px solid #2c3e50;
      padding-bottom: 0.3rem;
      margin-top: 0;
    }

    h2 {
      font-size: 1.8rem;
      color: #2c3e50;
      margin-top: 2rem;
      margin-bottom: 0.75rem;
      border-bottom: 2px solid #3c78d8ff;
      padding-bottom: 0.3rem;
    }

    h3 {
      font-size: 1.4rem;
      color: #2c3e50;
      margin-top: 1.5rem;
      margin-bottom: 0.5rem;
      font-weight: 600;
    }

    h4 {
      font-size: 1.2rem;
      color: #2c3e50;
      margin-top: 1.2rem;
      margin-bottom: 0.5rem;
      font-weight: 600;
    }

    h5, h6 {
      font-size: 1.1rem;
      color: #2c3e50;
      margin-top: 1rem;
      margin-bottom: 0.5rem;
      font-weight: 600;
    }

    p {
      margin-bottom: 1rem;
      color: #333;
      line-height: 1.7;
    }

    a {
      color: #3c78d8ff;
      text-decoration: none;
      transition: color 0.2s ease;
    }

    a:hover {
      color: #3c78d8ff;
      text-decoration: underline;
    }

    hr {
      border: none;
      border-top: 1px solid #ddd;
      margin: 2rem 0;
    }

    /* Code blocks */
    pre {
      background-color: #1e1e1e;
      color: #d4d4d4;
      padding: 1.5rem;
      border-radius: 0;
      overflow-x: auto;
      margin: 1.5rem 0;
      font-size: 0.875rem;
      line-height: 1.5;
      border: 1px solid #e0e0e0;
    }

    code {
      background-color: #f1f5f9;
      color: #333;
      padding: 0.125rem 0.375rem;
      border-radius: 0;
      font-size: 0.875rem;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'Courier New', monospace;
    }

    pre code {
      background-color: transparent;
      color: inherit;
      padding: 0;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'Courier New', monospace;
    }

    /* Lists */
    ul, ol {
      margin-bottom: 1rem;
      margin-left: 1.5rem;
    }

    li {
      margin-bottom: 0.5rem;
      color: #333;
      line-height: 1.6;
    }

    /* Tables */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1.5rem 0;
      background-color: #fff;
      border-radius: 0;
      overflow: hidden;
    }

    th, td {
      padding: 0.75rem 1rem;
      text-align: left;
      border-bottom: 1px solid #e0e0e0;
    }

    th {
      background-color: #f8f9fa;
      font-weight: 600;
      color: #2c3e50;
    }

    /* Blockquotes */
    blockquote {
      border-left: 4px solid #3c78d8ff;
      padding-left: 1rem;
      margin: 1.5rem 0;
      color: #555;
      font-style: italic;
    }

    /* Images */
    img {
      max-width: 100%;
      height: auto;
      border-radius: 0;
      margin: 1.5rem 0;
    }

    /* Math */
    .math {
      overflow-x: auto;
      overflow-y: hidden;
    }

    /* Responsive design */
    @media (max-width: 768px) {
      .container {
        padding: 1.5rem;
      }

      h1 {
        font-size: 1.8rem;
      }

      h2 {
        font-size: 1.5rem;
      }

      nav a {
        margin-right: 1.5rem;
        font-size: 1rem;
      }
      
      .series-hero {
        flex-direction: column;
        align-items: flex-start;
      }

      .series-cover {
        width: 100%;
        align-self: flex-start;
      }

      .post-images img {
        height: 96px;
      }
    }

    /* Series navigation */
    .series-nav {
      margin: 1.5rem 0 2.5rem;
      padding: 1.5rem;
      border: 1px solid #e0e0e0;
      background: #fafafa;
    }

    .series-eyebrow {
      font-size: 0.75rem;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      margin-bottom: 0.4rem;
    }

    .series-title {
      font-family: 'Merriweather', serif;
      font-size: 1.5rem;
      color: #2c3e50;
      margin: 0;
    }

    .series-hero {
      display: flex;
      align-items: center;
      gap: 1.5rem;
      margin: 0.75rem 0 1.2rem;
    }

    .series-cover {
      display: block;
      width: 20%;
      max-width: 520px;
      margin: 0;
      border: 1px solid #e0e0e0;
      background: #fff;
    }
    
    .series-blurb {
      flex: 1;
      margin: 0 0 0 20px;
      color: #888;
      font-size: 0.9rem;
      font-style: italic;
      line-height: 1.6;
      max-width: 400px;
    }

    /* Responsive design */
    @media (max-width: 768px) {
      .series-blurb {
        margin: 0 0 0 0;
      }
    }

    .series-toc-title {
      margin-top: 0.9rem;
      font-size: 1rem;
      color: #2c3e50;
      font-weight: 600;
    }

    .series-toc {
      margin: 0.4rem 0 0 1.2rem;
    }

    .series-toc li {
      margin-bottom: 0.4rem;
    }

    .series-toc a {
      color: #2c3e50;
    }

    .series-toc .is-current a {
      color: #3c78d8ff;
      font-weight: 600;
    }

    /* Next post card */
    .next-post {
      margin-top: 3rem;
      padding-top: 2rem;
      border-top: 1px solid #e0e0e0;
    }
    
    .next-post-label {
      font-size: 0.9rem;
      color: #888;
      margin-bottom: 1rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .next-post-card {
      display: block;
      text-decoration: none;
      color: inherit;
      padding: 1.5rem;
      border: 1px solid #e0e0e0;
      border-radius: 0;
      transition: all 0.3s ease;
      position: relative;
    }
    
    .next-post-card:hover {
      border-color: #3c78d8ff;
      box-shadow: 0 2px 8px rgba(52, 152, 219, 0.1);
      transform: translateY(-2px);
    }
    
    .next-post-card::after {
      content: "→";
      position: absolute;
      right: 1.5rem;
      top: 50%;
      transform: translateY(-50%);
      font-size: 1.5rem;
      color: #3c78d8ff;
      transition: transform 0.3s ease;
      font-weight: bold;
    }
    
    .next-post-card:hover::after {
      transform: translateY(-50%) translateX(5px);
    }
    
    .next-post-images {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    
    .next-post-images img {
      height: 120px;
      width: auto;
      border-radius: 0;
      display: block;
    }

    @media (max-width: 768px) {
      .next-post-images img {
        height: 80px;
      }
    }
    
    .next-post-title {
      font-family: 'Merriweather', serif;
      font-size: 1.5rem;
      color: #2c3e50;
      margin: 0;
      padding-right: 2rem;
    }
    
    .next-post-card:hover .next-post-title {
      color: #3c78d8ff;
    }
    
    /* Print styles */
    @media print {
      body {
        background: #fff;
      }
      
      .container {
        max-width: 100%;
        padding: 0;
      }
      
      .next-post {
        display: none;
      }

      .series-nav {
        display: none;
      }
    }
    
  </style>

    
    
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
  <div class="container">
    <nav>
      <a href="../index.html">Home</a>
      <a href="https://github.com/umbralcalc">GitHub</a>
      <a href="../cv.html">CV</a>
    </nav>

        <section class="series-nav" id="series-nav" data-series-tag="Simulating Real-World Systems as a Programmer" data-series-order="2">
      <div class="series-hero">
                <img class="series-cover" id="series-cover" src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/simulating-real-world-systems-as-a-programmer-cover.svg" alt="Simulating Real-World Systems as a Programmer cover" onerror="this.style.display='none'" />
                        <p class="series-blurb">A collection of posts on the foundations and patterns for building simulations of the real world. Written especially for programmers and non-technical readers wanting to learn the fundamentals. All written material and non-interactive diagrams were human-generated, where some interactive elements were programmed using generative AI tools.</p>
              </div>
      <div class="series-eyebrow">Collection</div>
      <h2 class="series-title">Simulating Real-World Systems as a Programmer</h2>
      <ol class="series-toc" id="series-toc"></ol>
    </section>
    
    <main>
      <h1 id="the-building-blocks-of-simulations">The building blocks of simulations</h1>
      <div style="height:0.75em;">

      </div>
      <h2 id="time-and-its-history">Time and its ‘history’</h2>
      <p>Time is probably the most important variable to track in a simulation. This is because everything that happens within a simulation only has meaning with respect to the real world if we can trace what point in simulated Time that it happened.</p>
      <p>Time is a variable in the simulation which always increases in value. We often want to track how it increases after each discrete simulation ‘step’ in increments which we shall call ‘Timesteps’.</p>
      <p>The first data structure which we shall introduce here is a ‘Cumulative Timesteps History’, which indexes simulated Times that the simulation <em>had</em> according to <em>decreasing recency</em>.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/the_building_blocks_of_simulations/cumulative-timesteps-history.svg" width=600/>
      </center>
      <h2 id="state-partitions-and-their-history">State partitions and their history</h2>
      <p>Simulations also have a ‘State’ associated to them for each value of Time.</p>
      <p>A simulation State holds all of the essential information we want to track to make the simulation useful to us which, crucially, includes <em>all of the information that is needed for the simulation to proceed</em>.</p>
      <p>In order to simplify how all of this State data is processed and retrieved, we’re going to <em>partition</em> this simulation State into several ‘State Partition’ data structures.</p>
      <p>For example, one of these partitions might hold all the data associated to a player in a sports team, and the whole simulation needs all of the players within its overall State.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/the_building_blocks_of_simulations/state-partitions.svg" width=600/>
      </center>
      <p>Each State Partition carries data that can be different for each moment in Time of the simulation. In order to track this evolution, we create a ‘State Partition History’ data structure for each State Partition.</p>
      <p>Each State Partition History has indices which always match those of the Cumulative Timesteps History, so they are always synchronised with each other.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/the_building_blocks_of_simulations/state-partition-history.svg" width=600/>
      </center>
      <h2 id="example-energy-usage-in-a-smart-building">Example: Energy usage in a smart building</h2>
      <div id="sim-history-demo" style="margin:1.5em 0;padding:1em;background:#ffffff;">
        <div style="border:1px solid #2c3e50;border-radius:6px;padding:0.6em;background:#ffffff;margin-bottom:0.9em;">
          <div style="font-weight:600;color:#2c3e50;margin-bottom:0.35em;padding:0 0.75em;">Overall time series (Temperature)</div>
          <svg id="sim-history-overall" width="100%" height="160" viewBox="0 0 320 160" role="img" aria-label="Overall time series"></svg>
          <div style="font-size:1rem;color:#2c3e50;padding:0 0.75em;margin-bottom:0.35em;">Highlighted window corresponds to the History panels below.</div>
        </div>
        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:0.9em;">
          <div style="border:1px solid #2c3e50;border-radius:6px;padding:0.6em;background:#ffffff;">
            <div style="font-weight:600;color:#2c3e50;margin-bottom:0.35em;padding:0 0.75em;">Cumulative Timesteps History</div>
            <svg id="sim-history-timeline" width="100%" height="140" viewBox="0 0 320 140" role="img" aria-label="Cumulative timesteps history"></svg>
            <div style="font-size:1rem;color:#2c3e50;margin-top:0.35em;padding:0 0.75em;">The most recent Time is at the top.</div>
          </div>
          <div style="border:1px solid #2c3e50;border-radius:6px;padding:0.6em;background:#ffffff;">
            <div style="font-weight:600;color:#2c3e50;margin-bottom:0.35em;padding:0 0.75em;">State Partition Histories</div>
            <svg id="sim-history-partitions" width="100%" height="140" viewBox="0 0 320 140" role="img" aria-label="State partition histories"></svg>
            <div id="sim-history-state" style="font-size:1rem;color:#2c3e50;margin-top:0.35em;line-height:1.4;padding:0 0.75em;margin-bottom:0.35em;"></div>
          </div>
        </div>
        <div style="display:flex;flex-wrap:wrap;gap:0.75em;align-items:center;justify-content:flex-start;margin-top:0.8em;">
          <button id="sim-history-step" type="button" style="cursor:pointer;border:1px solid #3c78d8;background:#3c78d8;color:#ffffff;padding:0.4em 0.8em;border-radius:6px;font-size:1rem;">
            Advance 1 Timestep
          </button>
          <button id="sim-history-reset" type="button" style="cursor:pointer;border:1px solid #2c3e50;background:#ffffff;color:#2c3e50;padding:0.4em 0.8em;border-radius:6px;font-size:1rem;">
            New Simulation Run
          </button>
        </div>
      </div>
      <script>
      (() => {
        const overallSvg = document.getElementById("sim-history-overall");
        const timelineSvg = document.getElementById("sim-history-timeline");
        const partitionsSvg = document.getElementById("sim-history-partitions");
        const stepButton = document.getElementById("sim-history-step");
        const resetButton = document.getElementById("sim-history-reset");
        const stateBox = document.getElementById("sim-history-state");
        if (!overallSvg || !timelineSvg || !partitionsSvg || !stepButton || !resetButton) return;

        const width = 320;
        const height = 140;
        const pad = 18;
        const maxHistory = 8;
        const totalSteps = 24;

        const createSvgEl = (name, attrs = {}) => {
          const el = document.createElementNS("http://www.w3.org/2000/svg", name);
          Object.entries(attrs).forEach(([key, value]) => el.setAttribute(key, value));
          return el;
        };

        const makeState = () => ({
          time: 0,
          history: [],
          overall: [],
          occupancy: 4 + Math.floor(Math.random() * 6),
          temperature: 20 + Math.random() * 2.5,
        });

        let sim = makeState();

        const advance = () => {
          const delta = 1;
          sim.time += delta;
          const occupancyDrift = Math.random() < 0.5 ? -1 : 1;
          sim.occupancy = Math.max(0, sim.occupancy + occupancyDrift + (Math.random() < 0.3 ? 1 : 0));
          const targetTemp = 19 + sim.occupancy * 0.25;
          sim.temperature += (targetTemp - sim.temperature) * 0.3 + (Math.random() - 0.5) * 0.4;

          sim.history.unshift({
            time: sim.time,
            occupancy: sim.occupancy,
            temperature: sim.temperature,
          });
          if (sim.history.length > maxHistory) {
            sim.history.pop();
          }
          sim.overall.push({
            time: sim.time,
            occupancy: sim.occupancy,
            temperature: sim.temperature,
          });
          if (sim.overall.length > totalSteps) {
            sim.overall.shift();
          }
        };

        const drawOverall = () => {
          overallSvg.innerHTML = "";
          const chartPad = 16;
          const innerWidth = width - 2 * chartPad;
          const innerHeight = height - 2 * chartPad;
          const temps = sim.overall.map((entry) => entry.temperature);
          const minTemp = Math.min(...temps);
          const maxTemp = Math.max(...temps);
          const range = maxTemp - minTemp || 1;

          overallSvg.appendChild(createSvgEl("rect", {
            x: chartPad,
            y: chartPad,
            width: innerWidth,
            height: innerHeight,
            fill: "#ffffff",
            stroke: "#2c3e50",
            "stroke-width": "1",
          }));

          const points = sim.overall.map((entry, idx) => {
            const x = chartPad + (idx / (totalSteps - 1)) * innerWidth;
            const y = chartPad + innerHeight - ((entry.temperature - minTemp) / range) * innerHeight;
            return { x, y };
          });

          if (points.length > 1) {
            const path = points.map((point, idx) => `${idx === 0 ? "M" : "L"}${point.x},${point.y}`).join(" ");
            overallSvg.appendChild(createSvgEl("path", {
              d: path,
              fill: "none",
              stroke: "#3c78d8",
              "stroke-width": "2",
            }));
          }

          points.forEach((point, idx) => {
            overallSvg.appendChild(createSvgEl("circle", {
              cx: point.x,
              cy: point.y,
              r: idx === points.length - 1 ? 3.5 : 2,
              fill: "#2c3e50",
            }));
          });

          const windowStart = Math.max(0, sim.overall.length - maxHistory);
          const windowX = chartPad + (windowStart / (totalSteps - 1)) * innerWidth;
          const windowWidth = ((sim.overall.length - windowStart - 1) / (totalSteps - 1)) * innerWidth;
          overallSvg.appendChild(createSvgEl("rect", {
            x: windowX,
            y: chartPad,
            width: Math.max(8, windowWidth),
            height: innerHeight,
            fill: "rgba(176,68,122,0.12)",
            stroke: "#b0447a",
            "stroke-width": "1",
            "stroke-dasharray": "4 3",
          }));
        };

        const drawTimeline = () => {
          timelineSvg.innerHTML = "";
          const rowHeight = (height - 2 * pad) / maxHistory;
          const startX = pad + 12;

          timelineSvg.appendChild(createSvgEl("line", {
            x1: startX,
            y1: pad,
            x2: startX,
            y2: height - pad,
            stroke: "#2c3e50",
            "stroke-width": "1",
          }));

          sim.history.forEach((entry, idx) => {
            const y = pad + rowHeight * idx + rowHeight / 2;
            timelineSvg.appendChild(createSvgEl("circle", {
              cx: startX,
              cy: y,
              r: 4,
              fill: idx === 0 ? "#b0447a" : "#2c3e50",
            }));
            timelineSvg.appendChild(createSvgEl("text", {
              x: startX + 12,
              y: y + 4,
              fill: "#2c3e50",
              "font-size": "11",
            })).textContent = `t = ${entry.time}`;
          });
        };

        const drawPartitions = () => {
          partitionsSvg.innerHTML = "";
          const rowHeight = (height - 2 * pad) / maxHistory;
          const startX = pad + 8;

          const minOcc = Math.min(...sim.history.map((h) => h.occupancy));
          const maxOcc = Math.max(...sim.history.map((h) => h.occupancy));
          const minTemp = Math.min(...sim.history.map((h) => h.temperature));
          const maxTemp = Math.max(...sim.history.map((h) => h.temperature));

          sim.history.forEach((entry, idx) => {
            const y = pad + rowHeight * idx + rowHeight / 2;
            const occWidth = maxOcc === minOcc ? 0.5 : (entry.occupancy - minOcc) / (maxOcc - minOcc);
            const tempWidth = maxTemp === minTemp ? 0.5 : (entry.temperature - minTemp) / (maxTemp - minTemp);

            partitionsSvg.appendChild(createSvgEl("rect", {
              x: startX,
              y: y - 8,
              width: 70 * occWidth + 10,
              height: 6,
              fill: "#b0447a",
              rx: "2",
            }));
            partitionsSvg.appendChild(createSvgEl("rect", {
              x: startX,
              y: y + 2,
              width: 70 * tempWidth + 10,
              height: 6,
              fill: "#3c78d8",
              rx: "2",
            }));

            partitionsSvg.appendChild(createSvgEl("text", {
              x: startX + 90,
              y: y + 4,
              fill: "#2c3e50",
              "font-size": "11",
            })).textContent = `occ ${entry.occupancy} | temp ${entry.temperature.toFixed(1)}°C`;
          });

        };

        const render = () => {
          if (sim.history.length === 0) {
            for (let i = 0; i < totalSteps; i += 1) {
              advance();
            }
          }
          drawOverall();
          drawTimeline();
          drawPartitions();
          if (stateBox && sim.history[0]) {
            const latest = sim.history[0];
            stateBox.innerHTML = `
              <div><strong>Latest Simulation State:</strong> Occupancy ${latest.occupancy}, Temperature ${latest.temperature.toFixed(1)}°C.</div>
              <div>Both Histories are indexed by the same Times.</div>
            `;
          }
        };

        stepButton.addEventListener("click", () => {
          advance();
          render();
        });

        resetButton.addEventListener("click", () => {
          sim = makeState();
          render();
        });

        render();
      })();
      </script>
      <h2 id="computing-the-next-timesteps">Computing the next timesteps</h2>
      <p>So new States of the simulation may happen at different Times. But what determines when these Times are along the Simulation Timeline?</p>
      <p>When simulating systems in the real world, it can be desireable in some situations to be able to structure the Times along the Timeline at regular intervals.</p>
      <p>In other situations it can be desirable to have an unstructured or randomly-drawn set of Times along the Timeline.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/the_building_blocks_of_simulations/timeline.svg" />
      </center>
      <p>In order to allow this flexibility in choice between situations, let’s specify an ‘Advance Time’ calculation which takes in the current Cumulative Timesteps History and outputs the Next Timestep following the latest Time found in the History (at index 0).</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/the_building_blocks_of_simulations/advance-time.svg" />
      </center>
      <h2 id="state-partition-iteration">State partition iteration</h2>
      <p>For an overall simulation data view, we can create a ‘State Partition Histories’ structure. This is a collection of each State Partition History that exists within the simulation.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/the_building_blocks_of_simulations/state-partition-histories.svg" width=600/>
      </center>
      <p>How do we determine the ‘Next Values’ of each State Partition in Time?</p>
      <p>This is where we should maintain full flexibility in choice of calculation so that our simulation is able to represent many different real-world systems.</p>
      <p>Each of these calculations for a given Partition specifies how the State Partition Histories and Cumulative Timesteps History data are used to determine the Next Values of the State Partition.</p>
      <p>In order to support even more flexibility in configuration, the calculation should also take in a set of Parameters which are specific to that Partition.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/the_building_blocks_of_simulations/partition-iteration.svg" />
      </center>
      <h2 id="state-partition-and-time-updates">State partition and time updates</h2>
      <p>Having calculated the Next Values of each State Partition and the Next Timestep, we should perform operations over the Cumulative Timesteps History and each State Partition History to Update their structures with this new data.</p>
      <p>This is an important procedure to perform all at once to ensure that the all of the State Partitions in the simulation are synchronised against its virtual clock.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/the_building_blocks_of_simulations/update-time-history.svg" />
      </center>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/the_building_blocks_of_simulations/update-state-partition-history.svg" />
      </center>
      <h2 id="composing-and-coordinating-partitions">Composing and coordinating partitions</h2>
      <p>So far we have considered Partition Iterations as occurring seperately within the simulation. But it is important for these separate Partitions to be able to pass information to each other.</p>
      <p>To understand why this is important, think of our sports team example earlier and how each player might change their behaviour depending on the positions of other players on the field. They need to know about each other.</p>
      <p>So how do we compose Partitions together so that information may be passed between them?</p>
      <p>In some sense, this happens already. Each Partition may read information from the State Partition Histories in the Iteration to its Next Values.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/the_building_blocks_of_simulations/partition-timeline-composition.svg" />
      </center>
      <p>This composition allows us to correlate the behaviour of Partitions in Time.</p>
      <p>We might also want to coordinate the Iterations of Partitions to occur in a particular order, where the first Iteration may then pass its calculated Next Values immediately into the second.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/the_building_blocks_of_simulations/partition-dependencies.svg" />
      </center>
      <p>For example, an Iteration might calculate the Mean statistic from some data and another might calculate the Variance. The Variance depends on the Mean so we need the Mean Next Values to be passed directly into the Variance to make sure these are always aligned in Time.</p>
      <p>To enable coordination, all we need is for a ‘Computationally Upstream’ Iteration to be allowed to pass its Next Values into the Parameters of a ‘Computationally Downstream’ Iteration.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/the_building_blocks_of_simulations/composing-partitions.svg" />
      </center>
      <h2 id="simulation-runs">Simulation runs</h2>
      <p>A ‘Simulation Run’ defines the evolution of a simulation State over some specified period in Time.</p>
      <p>Each Simulation Run has an Initial Time defined by an exact value, but the <em>end</em> Time may not be known exactly until the simulation has evolved to meet some Termination Condition.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/the_building_blocks_of_simulations/simulation-run.svg"/>
      </center>
      <p>The Termination Condition logically determines when the Simulation Run should end according to a pre-defined calculation.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/the_building_blocks_of_simulations/termination-condition.svg"/>
      </center>
      <h2 id="embedded-simulation-runs">Embedded simulation runs</h2>
      <p>Enabling whole ‘Inner’ Simulation Runs to start and complete within each Timestep of an ‘Outer’ Simulation Run is a very useful, and somewhat fundamental, building block for simulations in practice. We shall call these ‘Embedded Simulation Runs’.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/the_building_blocks_of_simulations/embedded-simulation-run.svg"/>
      </center>
      <p>There are then several ways one can think of to pass information from the Outer simulation into the Inner simulation prior to running it on each Timestep.</p>
      <p>Treating the Inner simulation as a Partition of the Outer simulation, one example is to simply pass Parameters from the Outer simulation into the Inner simulation, and nothing else.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/the_building_blocks_of_simulations/embedded-sim-iterate.svg" width=600/>
      </center>
      <p>Another example is to pass both the Cumulative Timesteps History and State Partition Histories from the Outer simulation into the Inner simulation, in addition to the Parameters.</p>
      <p>Consider how this might be used to create useful statistical operations over the history of the Outer simulation, e.g., like rolling window averages.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/the_building_blocks_of_simulations/embedded-sim-from-history.svg" width=600/>
      </center>
      <h2 id="example-rolling-future-temperature-forecast">Example: Rolling future temperature forecast</h2>
      <div id="embedded-run-demo" style="margin:1.5em 0;padding:1em;background:#ffffff;">
        <div style="border:1px solid #2c3e50;border-radius:6px;padding:0.6em;background:#ffffff;">
          <svg id="embedded-run-chart" width="100%" height="180" viewBox="0 0 320 180" role="img" aria-label="Rolling temperature forecast"></svg>
          <div id="embedded-run-state" style="font-size:1rem;color:#2c3e50;margin-top:0.35em;line-height:1.4;padding:0 0.75em;margin-bottom:0.35em;"></div>
        </div>
        <div style="display:flex;flex-wrap:wrap;gap:0.75em;align-items:center;justify-content:flex-start;margin-top:0.8em;">
          <button id="embedded-run-step" type="button" style="cursor:pointer;border:1px solid #3c78d8;background:#3c78d8;color:#ffffff;padding:0.4em 0.8em;border-radius:6px;font-size:1rem;">
            Advance Outer Simulation
          </button>
          <button id="embedded-run-reset" type="button" style="cursor:pointer;border:1px solid #2c3e50;background:#ffffff;color:#2c3e50;padding:0.4em 0.8em;border-radius:6px;font-size:1rem;">
            New Outer Simulation Run
          </button>
        </div>
      </div>
      <script>
      (() => {
        const chartSvg = document.getElementById("embedded-run-chart");
        const stepButton = document.getElementById("embedded-run-step");
        const resetButton = document.getElementById("embedded-run-reset");
        const stateBox = document.getElementById("embedded-run-state");
        if (!chartSvg || !stepButton || !resetButton) return;

        const width = 320;
        const height = 180;
        const pad = 18;
        const horizon = 6;
        const maxHistory = 18;

        const createSvgEl = (name, attrs = {}) => {
          const el = document.createElementNS("http://www.w3.org/2000/svg", name);
          Object.entries(attrs).forEach(([key, value]) => el.setAttribute(key, value));
          return el;
        };

        const makeState = () => ({
          time: 0,
          history: [],
          occupancy: 3 + Math.floor(Math.random() * 6),
          temperature: 20 + Math.random() * 2,
        });

        let sim = makeState();

        const advanceOuter = () => {
          sim.time += 1;
          sim.occupancy = Math.max(0, sim.occupancy + (Math.random() < 0.55 ? 1 : -1));
          const targetTemp = 19 + sim.occupancy * 0.3;
          sim.temperature += (targetTemp - sim.temperature) * 0.35 + (Math.random() - 0.5) * 0.4;
          sim.history.push({
            time: sim.time,
            occupancy: sim.occupancy,
            temperature: sim.temperature,
          });
          if (sim.history.length > maxHistory) {
            sim.history.shift();
          }
        };

        const runEmbeddedForecast = () => {
          const forecast = [];
          let temp = sim.temperature;
          let occ = sim.occupancy;
          for (let i = 0; i < horizon; i += 1) {
            occ = Math.max(0, occ + (Math.random() < 0.5 ? 1 : -1));
            const target = 19 + occ * 0.3;
            temp += (target - temp) * 0.35 + (Math.random() - 0.5) * 0.4;
            forecast.push(temp);
          }
          return forecast;
        };

        const mapPoints = (values, minVal, maxVal, startIndex = 0) => {
          const range = maxVal - minVal || 1;
          return values.map((value, idx) => {
            const t = startIndex + idx;
            const x = pad + (t / (maxHistory + horizon - 1)) * (width - 2 * pad);
            const y = height - pad - ((value - minVal) / range) * (height - 2 * pad);
            return { x, y };
          });
        };

        const drawLine = (svg, points, color, dash) => {
          if (points.length < 2) return;
          const path = points.map((point, idx) => `${idx === 0 ? "M" : "L"}${point.x},${point.y}`).join(" ");
          svg.appendChild(createSvgEl("path", {
            d: path,
            fill: "none",
            stroke: color,
            "stroke-width": "2",
            "stroke-dasharray": dash || "none",
          }));
        };

        const render = () => {
          if (sim.history.length === 0) {
            for (let i = 0; i < 6; i += 1) {
              advanceOuter();
            }
          }

          const forecast = runEmbeddedForecast();
          const pastTemps = sim.history.map((entry) => entry.temperature);
          const series = pastTemps.concat(forecast);
          const minVal = Math.min(...series);
          const maxVal = Math.max(...series);

          chartSvg.innerHTML = "";
          chartSvg.appendChild(createSvgEl("line", {
            x1: pad,
            y1: height - pad,
            x2: width - pad,
            y2: height - pad,
            stroke: "#2c3e50",
            "stroke-width": "1",
          }));
          chartSvg.appendChild(createSvgEl("line", {
            x1: pad,
            y1: pad,
            x2: pad,
            y2: height - pad,
            stroke: "#2c3e50",
            "stroke-width": "1",
          }));

          const pastPoints = mapPoints(pastTemps, minVal, maxVal, 0);
          const forecastPoints = mapPoints([sim.temperature].concat(forecast), minVal, maxVal, pastTemps.length - 1);
          drawLine(chartSvg, pastPoints, "#2c3e50");
          drawLine(chartSvg, forecastPoints, "#3c78d8", "5 4");

          const currentX = pad + ((pastTemps.length - 1) / (maxHistory + horizon - 1)) * (width - 2 * pad);
          chartSvg.appendChild(createSvgEl("line", {
            x1: currentX,
            y1: pad,
            x2: currentX,
            y2: height - pad,
            stroke: "#b0447a",
            "stroke-width": "1",
            "stroke-dasharray": "3 3",
          }));

          chartSvg.appendChild(createSvgEl("circle", {
            cx: pastPoints[pastPoints.length - 1].x,
            cy: pastPoints[pastPoints.length - 1].y,
            r: 3,
            fill: "#b0447a",
          }));

          const startPoint = pastPoints[pastPoints.length - 1];
          const endPoint = forecastPoints[forecastPoints.length - 1];
          const axisY = height - pad;
          const arrowY = axisY;
          chartSvg.appendChild(createSvgEl("line", {
            x1: startPoint.x,
            y1: arrowY,
            x2: endPoint.x,
            y2: arrowY,
            stroke: "#b0447a",
            "stroke-width": "1.5",
          }));

          const arrowSize = 6;
          chartSvg.appendChild(createSvgEl("polygon", {
            points: `${endPoint.x},${arrowY} ${endPoint.x - arrowSize},${arrowY - 4} ${endPoint.x - arrowSize},${arrowY + 4}`,
            fill: "#b0447a",
          }));

          const labelX = Math.min(endPoint.x - 6, startPoint.x + 8);
          chartSvg.appendChild(createSvgEl("text", {
            x: labelX,
            y: axisY + 14,
            fill: "#b0447a",
            "font-size": "10",
            "text-anchor": "start",
          })).textContent = "Embedded Simulation Run";

          if (stateBox) {
            stateBox.innerHTML = `
              <div><strong>Outer Simulation State:</strong> t=${sim.time}, Occupancy ${sim.occupancy}, Temperature ${sim.temperature.toFixed(1)}°C.</div>
              <div><strong>Embedded Simulation Run:</strong> forecast ${horizon} Timesteps ahead from the current State.</div>
            `;
          }
        };

        stepButton.addEventListener("click", () => {
          advanceOuter();
          render();
        });

        resetButton.addEventListener("click", () => {
          sim = makeState();
          render();
        });

        render();
      })();
      </script>
      
            <div class="next-post">
        <div class="next-post-label">Next Post</div>
        <a href="/posts/building_a_simulation_engine.html" class="next-post-card">
                    <div class="next-post-images" id="next-post-images"></div>
                    <div class="next-post-title">Building a simulation engine</div>
        </a>
      </div>
          </main>
  </div>
  
    <script>
    // Parse and display next post images
    (function() {
      const imagesContainer = document.getElementById('next-post-images');
      if (imagesContainer) {
        try {
          const imagesJson = '["https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/building_a_simulation_engine/stochadex-data-types.svg","https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/building_a_simulation_engine/fundamental-loop-code.svg"]';
          const images = JSON.parse(imagesJson);
          if (Array.isArray(images) && images.length > 0) {
            images.forEach(imagePath => {
              const img = document.createElement('img');
              img.src = imagePath;
              img.alt = 'Building a simulation engine';
              imagesContainer.appendChild(img);
            });
          }
        } catch (e) {
          console.error('Error parsing next post images:', e);
        }
      }
    })();
  </script>
  
  <script>
    // Build series navigation for collections
    (function() {
      const seriesNav = document.getElementById('series-nav');
      if (!seriesNav) {
        return;
      }

      const seriesTag = seriesNav.dataset.seriesTag;
      if (!seriesTag || seriesTag === 'Loose Threads') {
        return;
      }

      const currentSlug = (window.location.pathname.split('/').pop() || '')
        .replace('.html', '')
        .trim();

      fetch('/posts.json')
        .then(response => response.json())
        .then(posts => {
          const seriesPosts = posts
            .filter(post => post.tag === seriesTag)
            .sort((a, b) => {
              const orderA = a.order !== undefined ? a.order : 999;
              const orderB = b.order !== undefined ? b.order : 999;
              if (orderA !== orderB) {
                return orderA - orderB;
              }
              return (a.title || '').localeCompare(b.title || '');
            });

          if (seriesPosts.length === 0) {
            seriesNav.style.display = 'none';
            return;
          }

          const currentIndex = seriesPosts.findIndex(post => {
            if (post.slug && post.slug === currentSlug) {
              return true;
            }
            if (post.url && currentSlug) {
              return post.url.endsWith(`/posts/.html`);
            }
            return false;
          });

          const toc = document.getElementById('series-toc');
          if (toc) {
            seriesPosts.forEach((post, index) => {
              const item = document.createElement('li');
              if (index === currentIndex) {
                item.classList.add('is-current');
              }
              const link = document.createElement('a');
              link.href = post.url;
              link.textContent = post.title || post.slug || 'Untitled';
              item.appendChild(link);
              toc.appendChild(item);
            });
          }
        })
        .catch(error => {
          console.error('Error loading posts for series navigation:', error);
        });
    })();
  </script>
</body>
</html>
