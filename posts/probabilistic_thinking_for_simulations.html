<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="description" content="umbralcalculations - Visual explorations in computation, science and creative writing" />
  <meta name="keywords" content="computation, science, creative writing, simulation, data" />
  
  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="../assets/umbralcalculations-logo.svg">
  <link rel="icon" type="image/x-icon" href="../assets/favicon.ico">
  <link rel="apple-touch-icon" href="../assets/umbralcalculations-logo.svg">
  
  <title>Probabilistic thinking for simulations</title>
  
  <!-- Fonts -->
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Merriweather:wght@300;400;700&family=Open+Sans:wght@300;400;600&display=swap');
  </style>
  
  <!-- Prism.js for syntax highlighting -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-vs.min.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-go.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-shell-session.min.js"></script>
  
  <!-- Custom CSS -->
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Open Sans', sans-serif;
      line-height: 1.6;
      color: #333;
      background: #fafafa;
      padding: 0;
      margin: 0;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 2rem;
      background: #fff;
      min-height: 100vh;
    }

    nav {
      margin-bottom: 3rem;
      padding-bottom: 1.5rem;
      border-bottom: 2px solid #e0e0e0;
      white-space: nowrap;
    }

    nav a {
      color: #2c3e50;
      text-decoration: none;
      font-weight: 600;
      margin-right: 2rem;
      transition: color 0.3s;
      font-size: 1.1rem;
      display: inline-block;
    }

    nav a:hover {
      color: #b0447aff;
      text-decoration: none;
    }

    /* Typography */
    h1, h2, h3, h4, h5, h6 {
      font-family: 'Merriweather', serif;
      color: #1a1a1a;
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      line-height: 1.3;
    }

    h1 {
      font-size: 2rem;
      color: #1a1a1a;
      margin-bottom: 0.5rem;
      border-bottom: 3px solid #2c3e50;
      padding-bottom: 0.3rem;
      margin-top: 0;
    }

    h2 {
      font-size: 1.8rem;
      color: #2c3e50;
      margin-top: 2rem;
      margin-bottom: 0.75rem;
      border-bottom: 2px solid #3c78d8ff;
      padding-bottom: 0.3rem;
    }

    h3 {
      font-size: 1.4rem;
      color: #2c3e50;
      margin-top: 1.5rem;
      margin-bottom: 0.5rem;
      font-weight: 600;
    }

    h4 {
      font-size: 1.2rem;
      color: #2c3e50;
      margin-top: 1.2rem;
      margin-bottom: 0.5rem;
      font-weight: 600;
    }

    h5, h6 {
      font-size: 1.1rem;
      color: #2c3e50;
      margin-top: 1rem;
      margin-bottom: 0.5rem;
      font-weight: 600;
    }

    p {
      margin-bottom: 1rem;
      color: #333;
      line-height: 1.7;
    }

    a {
      color: #3c78d8ff;
      text-decoration: none;
      transition: color 0.2s ease;
    }

    a:hover {
      color: #3c78d8ff;
      text-decoration: underline;
    }

    hr {
      border: none;
      border-top: 1px solid #ddd;
      margin: 2rem 0;
    }

    /* Code blocks */
    pre {
      background-color: #1e1e1e;
      color: #d4d4d4;
      padding: 1.5rem;
      border-radius: 0;
      overflow-x: auto;
      margin: 1.5rem 0;
      font-size: 0.875rem;
      line-height: 1.5;
      border: 1px solid #e0e0e0;
    }

    code {
      background-color: #f1f5f9;
      color: #333;
      padding: 0.125rem 0.375rem;
      border-radius: 0;
      font-size: 0.875rem;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'Courier New', monospace;
    }

    pre code {
      background-color: transparent;
      color: inherit;
      padding: 0;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'Courier New', monospace;
    }

    /* Lists */
    ul, ol {
      margin-bottom: 1rem;
      margin-left: 1.5rem;
    }

    li {
      margin-bottom: 0.5rem;
      color: #333;
      line-height: 1.6;
    }

    /* Tables */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1.5rem 0;
      background-color: #fff;
      border-radius: 0;
      overflow: hidden;
    }

    th, td {
      padding: 0.75rem 1rem;
      text-align: left;
      border-bottom: 1px solid #e0e0e0;
    }

    th {
      background-color: #f8f9fa;
      font-weight: 600;
      color: #2c3e50;
    }

    /* Blockquotes */
    blockquote {
      border-left: 4px solid #3c78d8ff;
      padding-left: 1rem;
      margin: 1.5rem 0;
      color: #555;
      font-style: italic;
    }

    /* Images */
    img {
      max-width: 100%;
      height: auto;
      border-radius: 0;
      margin: 1.5rem 0;
    }

    /* Math */
    .math {
      overflow-x: auto;
      overflow-y: hidden;
    }

    /* Responsive design */
    @media (max-width: 768px) {
      .container {
        padding: 1.5rem;
      }

      h1 {
        font-size: 1.8rem;
      }

      h2 {
        font-size: 1.5rem;
      }

      nav a {
        margin-right: 1.5rem;
        font-size: 1rem;
      }
      
      .series-hero {
        flex-direction: column;
        align-items: flex-start;
      }

      .series-cover {
        width: 100%;
        align-self: flex-start;
      }

      .post-images img {
        height: 96px;
      }
    }

    /* Series navigation */
    .series-nav {
      margin: 1.5rem 0 2.5rem;
      padding: 1.5rem;
      border: 1px solid #e0e0e0;
      background: #fafafa;
    }

    .series-eyebrow {
      font-size: 0.75rem;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      margin-bottom: 0.4rem;
    }

    .series-title {
      font-family: 'Merriweather', serif;
      font-size: 1.5rem;
      color: #2c3e50;
      margin: 0;
    }

    .series-hero {
      display: flex;
      align-items: center;
      gap: 1.5rem;
      margin: 0.75rem 0 1.2rem;
    }

    .series-cover {
      display: block;
      width: 20%;
      max-width: 520px;
      margin: 0;
      border: 1px solid #e0e0e0;
      background: #fff;
    }
    
    .series-blurb {
      flex: 1;
      margin: 0 0 0 20px;
      color: #888;
      font-size: 0.9rem;
      font-style: italic;
      line-height: 1.6;
      max-width: 400px;
    }

    /* Responsive design */
    @media (max-width: 768px) {
      .series-blurb {
        margin: 0 0 0 0;
      }
    }

    .series-toc-title {
      margin-top: 0.9rem;
      font-size: 1rem;
      color: #2c3e50;
      font-weight: 600;
    }

    .series-toc {
      margin: 0.4rem 0 0 1.2rem;
    }

    .series-toc li {
      margin-bottom: 0.4rem;
    }

    .series-toc a {
      color: #2c3e50;
    }

    .series-toc .is-current a {
      color: #3c78d8ff;
      font-weight: 600;
    }

    /* Next post card */
    .next-post {
      margin-top: 3rem;
      padding-top: 2rem;
      border-top: 1px solid #e0e0e0;
    }
    
    .next-post-label {
      font-size: 0.9rem;
      color: #888;
      margin-bottom: 1rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .next-post-card {
      display: block;
      text-decoration: none;
      color: inherit;
      padding: 1.5rem;
      border: 1px solid #e0e0e0;
      border-radius: 0;
      transition: all 0.3s ease;
      position: relative;
    }
    
    .next-post-card:hover {
      border-color: #3c78d8ff;
      box-shadow: 0 2px 8px rgba(52, 152, 219, 0.1);
      transform: translateY(-2px);
    }
    
    .next-post-card::after {
      content: "→";
      position: absolute;
      right: 1.5rem;
      top: 50%;
      transform: translateY(-50%);
      font-size: 1.5rem;
      color: #3c78d8ff;
      transition: transform 0.3s ease;
      font-weight: bold;
    }
    
    .next-post-card:hover::after {
      transform: translateY(-50%) translateX(5px);
    }
    
    .next-post-images {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    
    .next-post-images img {
      height: 120px;
      width: auto;
      border-radius: 0;
      display: block;
    }

    @media (max-width: 768px) {
      .next-post-images img {
        height: 80px;
      }
    }
    
    .next-post-title {
      font-family: 'Merriweather', serif;
      font-size: 1.5rem;
      color: #2c3e50;
      margin: 0;
      padding-right: 2rem;
    }
    
    .next-post-card:hover .next-post-title {
      color: #3c78d8ff;
    }
    
    /* Print styles */
    @media print {
      body {
        background: #fff;
      }
      
      .container {
        max-width: 100%;
        padding: 0;
      }
      
      .next-post {
        display: none;
      }

      .series-nav {
        display: none;
      }
    }
    
  </style>

    
    
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
  <div class="container">
    <nav>
      <a href="../index.html">Home</a>
      <a href="https://github.com/umbralcalc">GitHub</a>
      <a href="../cv.html">CV</a>
    </nav>

        <section class="series-nav" id="series-nav" data-series-tag="Simulating Real-World Systems as a Programmer" data-series-order="4">
      <div class="series-hero">
                <img class="series-cover" id="series-cover" src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/simulating-real-world-systems-as-a-programmer-cover.svg" alt="Simulating Real-World Systems as a Programmer cover" onerror="this.style.display='none'" />
                        <p class="series-blurb">A collection of posts on the foundations and patterns for building simulations of the real world. Written especially for programmers and non-technical readers wanting to learn the fundamentals. All written material and non-interactive diagrams were human-generated, where some interactive elements were programmed using generative AI tools.</p>
              </div>
      <div class="series-eyebrow">Collection</div>
      <h2 class="series-title">Simulating Real-World Systems as a Programmer</h2>
      <ol class="series-toc" id="series-toc"></ol>
    </section>
    
    <main>
      <h1 id="probabilistic-thinking-for-simulations">Probabilistic thinking for simulations</h1>
      <div style="height:0.75em;">

      </div>
      <h2 id="why-do-we-care">Why do we care?</h2>
      <p>The ‘Trajectory’ of a simulation is the sequence of possible State Values that its Partitions actually take during a specific Simulation Run.</p>
      <p>Probabilities can represent sampling all of the possible Trajectories that a simulation could take in Time, simultaneously.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/probabilistic_thinking_for_simulations/probabilites-vs-trajectories.svg" />
      </center>
      <p>Using this representation for a real-world simulation, there are two important use cases.</p>
      <p>The first uses all of the possible Trajectories the simulation can take to represent how likely it is to take them. This makes it possible to create algorithms which learn the most likely Parameters for State Partitions to match real-world Data.</p>
      <p>The second uses the Probabilities to represent a model in place of the simulation itself. In the right circumstances, this results in algorithms which are much more efficient than sampling multiple Trajectories explicitly.</p>
      <h2 id="probabilities-and-regions">Probabilities and regions</h2>
      <p>Evaluating the Probability of a particular State Partition History, given Parameters and a Cumulative Timesteps History, looks a similar to the Iterate computation. However, in contrast, this computation does <em>not</em> progress forward in Time.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/probabilistic_thinking_for_simulations/evaluate-probability-partition.svg" />
      </center>
      <p>We might also want to evaluate the Probability of Regions which join together possible values that the whole State Partition History can take.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/probabilistic_thinking_for_simulations/possible-region.svg" />
      </center>
      <p>In many situations, it would be impossible to count the all of the possible values in some Regions, but we can still imagine the computation in this way.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/probabilistic_thinking_for_simulations/evaluate-probability-partition-region.svg" />
      </center>
      <h2 id="conditional-probabilities">Conditional probabilities</h2>
      <p>We can relate two successive probability evaluations in Time together by making the answer of the second depend on the outcome of the first.</p>
      <p>We call the second of these two evaluations a Conditional Probability because its Probability is <em>conditional</em> on the Probability of the first.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/probabilistic_thinking_for_simulations/conditional-probability.svg" />
      </center>
      <p>The Probabilities for the whole State Partition History change as the simulation advances in Time by adding the Next State Partition Values into the History.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/probabilistic_thinking_for_simulations/evolving-state-partition-history-probability.svg" />
      </center>
      <p>This concept also applies to the Probability of Regions.</p>
      <p>Note how this relationship also describes how the Probabilities of State Partition Histories can evolve in Time. One applies the same calculation to the output from the previous one, and so on, recursively.</p>
      <p>So why can’t we just use this recursive relationship to model all the trajectories of the simulation at once? For some simpler systems this is indeed possible, but for most simulations in practice this is computationally infeasible.</p>
      <p>Think about how one might store the set of all Possible State Partition Histories for a sequence of coin flips, and then how this can proliferate in Time as the simulation advances.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/probabilistic_thinking_for_simulations/coin-flips-tree.svg" />
      </center>
      <p>The Possible State Partition Histories grow even though the Possible State Values of a coin flip always remain the same (Heads or Tails).</p>
      <p>In practice, for most real-world systems, the set of Possible State Values <em>also</em> grows. To see how this can be the case, consider the Trajectories of a randomly moving point on a simple 2-dimensional grid.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/probabilistic_thinking_for_simulations/random-walker-grid.svg" />
      </center>
      <h2 id="estimating-the-probabilities-of-state-values">Estimating the probabilities of state values</h2>
      <p>There is a way we can compute these Probabilities without having to trace the path of every possible Trajectory, and often without having to keep a record of every Possible State Value.</p>
      <p>We start by estimating the Statistics of these Probabilities.</p>
      <p>The simplest example of these Statistics is the Estimated Mean State Value.</p>
      <p>The obvious way to calculate this is to take the average State Value for a given Timestep across multiple simulation Trajectories.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/probabilistic_thinking_for_simulations/average-across-trajectories.svg" />
      </center>
      <p>But could we get an estimate of Statistics from only one Trajectory? This would save lots of additional Trajectory computation as a result.</p>
      <p>Yes! If we have an accurate ‘weighting model’ for the past values, we can get an Estimated Mean State Value from a weighted average over the full State Partition History.</p>
      <p><Illustrate weighted average from state partition history></p>
      <p>We might also train a Machine Learning model to predict the Statistics of State Values from the full State Partition History as an alternative.</p>
      <p>Note that there are situations where using the State Partition Histories from one Trajectory is not equivalent to using multiple Trajectories (see <a href="https://en.wikipedia.org/wiki/Ergodicity">Ergodicity</a>). But this kind of technical problem can often be mitigated by using some mix of the two methods.</p>
      <p>So we have the Statistics, but where have the Probabilities gone?</p>
      <p>There are many different types of mathematical formulae or Machine Learning model which can provide a map back from these estimated Statistics into Probabilities of State Values in Time for either one or multiple Trajectories, depending on the right circumstances.</p>
      <p>&lt;Normal, Gamma, Binomial, Poisson, Negative Binomial distribution illustrations with statistics&gt;</p>
      <p>Using calculations of the estimated Statistics for a single Trajectory from the State Partition History, we can design a ‘Probabilistic Sample Weighting’ algorithm using the <a href="https://umbralcalc.github.io/stochadex">stochadex simulation engine</a>.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/probabilistic_thinking_for_simulations/prob-reweighting-code.svg" />
      </center>
      <p>This algorithm essentially compresses the information held within the State Partition History into a small amount of data in the form of Statistics. It then uses these Statistics to calculate estimated Probabilities for any Possible State Value in Time.</p>
      <h2 id="returning-to-why-we-care">Returning to why we care</h2>
      <p>To be continued…</p>
      
          </main>
  </div>
  
    <script>
    // Parse and display next post images
    (function() {
      const imagesContainer = document.getElementById('next-post-images');
      if (imagesContainer) {
        try {
          const imagesJson = '[]';
          const images = JSON.parse(imagesJson);
          if (Array.isArray(images) && images.length > 0) {
            images.forEach(imagePath => {
              const img = document.createElement('img');
              img.src = imagePath;
              img.alt = '';
              imagesContainer.appendChild(img);
            });
          }
        } catch (e) {
          console.error('Error parsing next post images:', e);
        }
      }
    })();
  </script>
  
  <script>
    // Build series navigation for collections
    (function() {
      const seriesNav = document.getElementById('series-nav');
      if (!seriesNav) {
        return;
      }

      const seriesTag = seriesNav.dataset.seriesTag;
      if (!seriesTag || seriesTag === 'Loose Threads') {
        return;
      }

      const currentSlug = (window.location.pathname.split('/').pop() || '')
        .replace('.html', '')
        .trim();

      fetch('/posts.json')
        .then(response => response.json())
        .then(posts => {
          const seriesPosts = posts
            .filter(post => post.tag === seriesTag)
            .sort((a, b) => {
              const orderA = a.order !== undefined ? a.order : 999;
              const orderB = b.order !== undefined ? b.order : 999;
              if (orderA !== orderB) {
                return orderA - orderB;
              }
              return (a.title || '').localeCompare(b.title || '');
            });

          if (seriesPosts.length === 0) {
            seriesNav.style.display = 'none';
            return;
          }

          const currentIndex = seriesPosts.findIndex(post => {
            if (post.slug && post.slug === currentSlug) {
              return true;
            }
            if (post.url && currentSlug) {
              return post.url.endsWith(`/posts/.html`);
            }
            return false;
          });

          const toc = document.getElementById('series-toc');
          if (toc) {
            seriesPosts.forEach((post, index) => {
              const item = document.createElement('li');
              if (index === currentIndex) {
                item.classList.add('is-current');
              }
              const link = document.createElement('a');
              link.href = post.url;
              link.textContent = post.title || post.slug || 'Untitled';
              item.appendChild(link);
              toc.appendChild(item);
            });
          }
        })
        .catch(error => {
          console.error('Error loading posts for series navigation:', error);
        });
    })();
  </script>
</body>
</html>
