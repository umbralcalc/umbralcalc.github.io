<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="description" content="umbralcalculations - Visual explorations in computation, science and creative writing" />
  <meta name="keywords" content="computation, science, creative writing, simulation, data" />
  
  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="../assets/umbralcalculations-logo.svg">
  <link rel="icon" type="image/x-icon" href="../assets/favicon.ico">
  <link rel="apple-touch-icon" href="../assets/umbralcalculations-logo.svg">
  
  <title>Architectures for current and future hardware</title>
  
  <!-- Fonts -->
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Merriweather:wght@300;400;700&family=Open+Sans:wght@300;400;600&display=swap');
  </style>
  
  <!-- Prism.js for syntax highlighting -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-vs.min.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-go.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-shell-session.min.js"></script>
  
  <!-- Custom CSS -->
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Open Sans', sans-serif;
      line-height: 1.6;
      color: #333;
      background: #fafafa;
      padding: 0;
      margin: 0;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 2rem;
      background: #fff;
      min-height: 100vh;
    }

    nav {
      margin-bottom: 3rem;
      padding-bottom: 1.5rem;
      border-bottom: 2px solid #e0e0e0;
      white-space: nowrap;
    }

    nav a {
      color: #2c3e50;
      text-decoration: none;
      font-weight: 600;
      margin-right: 2rem;
      transition: color 0.3s;
      font-size: 1.1rem;
      display: inline-block;
    }

    nav a:hover {
      color: #b0447aff;
      text-decoration: none;
    }

    /* Typography */
    h1, h2, h3, h4, h5, h6 {
      font-family: 'Merriweather', serif;
      color: #1a1a1a;
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      line-height: 1.3;
    }

    h1 {
      font-size: 2rem;
      color: #1a1a1a;
      margin-bottom: 0.5rem;
      border-bottom: 3px solid #2c3e50;
      padding-bottom: 0.3rem;
      margin-top: 0;
    }

    h2 {
      font-size: 1.8rem;
      color: #2c3e50;
      margin-top: 2rem;
      margin-bottom: 0.75rem;
      border-bottom: 2px solid #3c78d8ff;
      padding-bottom: 0.3rem;
    }

    h3 {
      font-size: 1.4rem;
      color: #2c3e50;
      margin-top: 1.5rem;
      margin-bottom: 0.5rem;
      font-weight: 600;
    }

    h4 {
      font-size: 1.2rem;
      color: #2c3e50;
      margin-top: 1.2rem;
      margin-bottom: 0.5rem;
      font-weight: 600;
    }

    h5, h6 {
      font-size: 1.1rem;
      color: #2c3e50;
      margin-top: 1rem;
      margin-bottom: 0.5rem;
      font-weight: 600;
    }

    p {
      margin-bottom: 1rem;
      color: #333;
      line-height: 1.7;
    }

    a {
      color: #3c78d8ff;
      text-decoration: none;
      transition: color 0.2s ease;
    }

    a:hover {
      color: #3c78d8ff;
      text-decoration: underline;
    }

    hr {
      border: none;
      border-top: 1px solid #ddd;
      margin: 2rem 0;
    }

    /* Code blocks */
    pre {
      background-color: #1e1e1e;
      color: #d4d4d4;
      padding: 1.5rem;
      border-radius: 0;
      overflow-x: auto;
      margin: 1.5rem 0;
      font-size: 0.875rem;
      line-height: 1.5;
      border: 1px solid #e0e0e0;
    }

    code {
      background-color: #f1f5f9;
      color: #333;
      padding: 0.125rem 0.375rem;
      border-radius: 0;
      font-size: 0.875rem;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'Courier New', monospace;
    }

    pre code {
      background-color: transparent;
      color: inherit;
      padding: 0;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'Courier New', monospace;
    }

    /* Lists */
    ul, ol {
      margin-bottom: 1rem;
      margin-left: 1.5rem;
    }

    li {
      margin-bottom: 0.5rem;
      color: #333;
      line-height: 1.6;
    }

    /* Tables */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1.5rem 0;
      background-color: #fff;
      border-radius: 0;
      overflow: hidden;
    }

    th, td {
      padding: 0.75rem 1rem;
      text-align: left;
      border-bottom: 1px solid #e0e0e0;
    }

    th {
      background-color: #f8f9fa;
      font-weight: 600;
      color: #2c3e50;
    }

    /* Blockquotes */
    blockquote {
      border-left: 4px solid #3c78d8ff;
      padding-left: 1rem;
      margin: 1.5rem 0;
      color: #555;
      font-style: italic;
    }

    /* Images */
    img {
      max-width: 100%;
      height: auto;
      border-radius: 0;
      margin: 1.5rem 0;
    }

    /* Math */
    .math {
      overflow-x: auto;
      overflow-y: hidden;
    }

    /* Responsive design */
    @media (max-width: 768px) {
      .container {
        padding: 1.5rem;
      }

      h1 {
        font-size: 1.8rem;
      }

      h2 {
        font-size: 1.5rem;
      }

      nav a {
        margin-right: 1.5rem;
        font-size: 1rem;
      }
      
      .series-hero {
        flex-direction: column;
        align-items: flex-start;
      }

      .series-cover {
        width: 100%;
        align-self: flex-start;
      }

      .post-images img {
        height: 96px;
      }
    }

    /* Series navigation */
    .series-nav {
      margin: 1.5rem 0 2.5rem;
      padding: 1.5rem;
      border: 1px solid #e0e0e0;
      background: #fafafa;
    }

    .series-eyebrow {
      font-size: 0.75rem;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      margin-bottom: 0.4rem;
    }

    .series-title {
      font-family: 'Merriweather', serif;
      font-size: 1.5rem;
      color: #2c3e50;
      margin: 0;
    }

    .series-hero {
      display: flex;
      align-items: center;
      gap: 1.5rem;
      margin: 0.75rem 0 1.2rem;
    }

    .series-cover {
      display: block;
      width: 20%;
      max-width: 520px;
      margin: 0;
      border: 1px solid #e0e0e0;
      background: #fff;
    }
    
    .series-blurb {
      flex: 1;
      margin: 0 0 0 20px;
      color: #888;
      font-size: 0.9rem;
      font-style: italic;
      line-height: 1.6;
      max-width: 400px;
    }

    /* Responsive design */
    @media (max-width: 768px) {
      .series-blurb {
        margin: 0 0 0 0;
      }
    }

    .series-toc-title {
      margin-top: 0.9rem;
      font-size: 1rem;
      color: #2c3e50;
      font-weight: 600;
    }

    .series-toc {
      margin: 0.4rem 0 0 1.2rem;
    }

    .series-toc li {
      margin-bottom: 0.4rem;
    }

    .series-toc a {
      color: #2c3e50;
    }

    .series-toc .is-current a {
      color: #3c78d8ff;
      font-weight: 600;
    }

    /* Next post card */
    .next-post {
      margin-top: 3rem;
      padding-top: 2rem;
      border-top: 1px solid #e0e0e0;
    }
    
    .next-post-label {
      font-size: 0.9rem;
      color: #888;
      margin-bottom: 1rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .next-post-card {
      display: block;
      text-decoration: none;
      color: inherit;
      padding: 1.5rem;
      border: 1px solid #e0e0e0;
      border-radius: 0;
      transition: all 0.3s ease;
      position: relative;
    }
    
    .next-post-card:hover {
      border-color: #3c78d8ff;
      box-shadow: 0 2px 8px rgba(52, 152, 219, 0.1);
      transform: translateY(-2px);
    }
    
    .next-post-card::after {
      content: "→";
      position: absolute;
      right: 1.5rem;
      top: 50%;
      transform: translateY(-50%);
      font-size: 1.5rem;
      color: #3c78d8ff;
      transition: transform 0.3s ease;
      font-weight: bold;
    }
    
    .next-post-card:hover::after {
      transform: translateY(-50%) translateX(5px);
    }
    
    .next-post-images {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    
    .next-post-images img {
      height: 120px;
      width: auto;
      border-radius: 0;
      display: block;
    }

    @media (max-width: 768px) {
      .next-post-images img {
        height: 80px;
      }
    }
    
    .next-post-title {
      font-family: 'Merriweather', serif;
      font-size: 1.5rem;
      color: #2c3e50;
      margin: 0;
      padding-right: 2rem;
    }
    
    .next-post-card:hover .next-post-title {
      color: #3c78d8ff;
    }
    
    /* Print styles */
    @media print {
      body {
        background: #fff;
      }
      
      .container {
        max-width: 100%;
        padding: 0;
      }
      
      .next-post {
        display: none;
      }

      .series-nav {
        display: none;
      }
    }
    
  </style>

    
    
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
  <div class="container">
    <nav>
      <a href="../index.html">Home</a>
      <a href="https://github.com/umbralcalc">GitHub</a>
      <a href="../cv.html">CV</a>
    </nav>

        <section class="series-nav" id="series-nav" data-series-tag="Simulating Real-World Systems as a Programmer" data-series-order="4">
      <div class="series-hero">
                <img class="series-cover" id="series-cover" src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/simulating-real-world-systems-as-a-programmer-cover.svg" alt="Simulating Real-World Systems as a Programmer cover" onerror="this.style.display='none'" />
                        <p class="series-blurb">A collection of posts on the foundations and patterns for building simulations of the real world. Written especially for programmers and non-technical readers wanting to learn the fundamentals. All written material and non-interactive diagrams were human-generated, where some interactive elements were programmed using generative AI tools.</p>
              </div>
      <div class="series-eyebrow">Collection</div>
      <h2 class="series-title">Simulating Real-World Systems as a Programmer</h2>
      <ol class="series-toc" id="series-toc"></ol>
    </section>
    
    <main>
      <h1 id="architectures-for-current-and-future-hardware">Architectures for current and future hardware</h1>
      <div style="height:0.75em;">

      </div>
      <h2 id="classical-hardware">Classical hardware</h2>
      <p>When we talk about ‘classical’ hardware here, we just mean standard CPUs.</p>
      <p>On CPUs, simulation architectures may be constructed out of several ingredients. Loosely speaking, these are: Memory, Threads, Channels between Threads, Processes and Inter-Process Communication (IPC).</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/architectures_for_current_and_future_hardware/cpu-graph-edges.svg"/>
      </center>
      <p>All of these ingredients have their own tradeoffs in performance. But they are all useful in constructing the right simulation architectures to satisfy the right use cases.</p>
      <p>In all of the previous posts so far, the main simulation architectures we have been considering are defined as Stepwise; simulation architectures which evaluate the Next State Values for the system at each point in Time, in turn.</p>
      <p>Stepwise simulation architectures on CPUs are typically more performant when using Memory, Threads and Channels between Threads in the right combinations.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/architectures_for_current_and_future_hardware/cpu-stepwise-architectures.svg" width=600/>
      </center>
      <p>In contrast, Processes, and IPC in particular, are typically more useful when we consider scaling computations in parallel across multiple non-interacting simulation Trajectories (which don’t need much IPC). This is because IPC comes with more performance limitations.</p>
      <p>Batch simulation architectures evaluate multiple successive sequences of Next State Values for the system over a wider interval in Time all as one computational block.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/architectures_for_current_and_future_hardware/stepwise-vs-batch.svg" width=600/>
      </center>
      <p>Despite their appearance, Batch simulation architectures cannot fundamentally evaluate the Next State Values at different Timesteps in a truly parallel fashion. Simulations must still preserve the causal relationships between these Next State Values as they progress in Time.</p>
      <p>To ensure this causality, some form of Iteration can be performed; like the Stepwise architecture implies by evaluating it recursively.</p>
      <p>However, it is sometimes sufficient to simply encode the causal/temporal dependencies between State Values along the Simulation Timeline as part of a Batch prediction; which is how some Machine Learning models are used to predict time series data.</p>
      <h2 id="specialised-classical-hardware">Specialised classical hardware</h2>
      <p>From the perspective of standard CPUs, Batch simulation architectures are often designed to evaluate segments of the Simulation Timeline using specialised classical hardware.</p>
      <p>When we talk about ‘specialised classical’ hardware here, we mean <a href="https://en.wikipedia.org/wiki/Graphics_processing_unit">GPUs</a>, <a href="https://en.wikipedia.org/wiki/Tensor_Processing_Unit">TPUs</a>, <a href="https://www.graphcore.ai/products/ipu">IPUs</a> and other specialised processors based on classical computing principles (as opposed to quantum processors).</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/architectures_for_current_and_future_hardware/specialised-classical-batch.svg"/>
      </center>
      <p>This architecture can be used to reduce the overall processing time taken to complete a Simulation Run relative to a Stepwise equivalent, but there are tradeoffs which mean this isn’t always efficient.</p>
      <p>GPUs, TPUs, IPUs, etc. all have their limitations. For example, GPUs and TPUs are highly optimised for dense arithmetic operations but struggle with branching control flow. IPUs offer more flexibility for irregular compute patterns and sparse operations, though they still prioritise throughput over the complex sequential logic that CPUs handle well.</p>
      <p>So there are basically certain types of simulation algorithm that can be written that GPUs, TPUs, IPUs, etc. are not well-suited to reducing the overall processing time for.</p>
      <p>In addition, this specialised hardware typically requires data transfer to/from CPU Memory (at the very least for initialization and final results), which also takes processing time.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/architectures_for_current_and_future_hardware/processing-time-per-timestep.svg"/>
      </center>
      <p>So, when deciding on the number of Timesteps a Batch simulation architecture should use for the best performance, software engineers must take into account:</p>
      <ul>
      <li>the available Memory of their specialised hardware</li>
      <li>the Memory requirements for their simulation State Partition Histories</li>
      <li>the overall number of Timesteps they need to perform</li>
      <li>the implications this has on the number of I/O operations needed to interact with CPU Memory</li>
      <li>and the implications <em>this</em> has on reducing the overall processing time, given the specialised hardware.</li>
      </ul>
      <h2 id="quantum-hardware">Quantum hardware</h2>
      <p>So if I wanted to measure a time series metric of the system I would have to create some partition of the quantum state which recorded this time series as a whole in Memory before collapsing the quantum state at the end to retrieve the time series.</p>
      <p>Therefore, you only get a quantum advantage at all if you can store more than one timestep worth of simulation metric states in qubit Memory. Otherwise, if you only effectively have one instantaneous timestep of qubit Memory to use the runtime will be denominated by I/O writing to and from the qubit states during the simulation runtime. This is the quantum I/O bottleneck.</p>
      <p>Work In Progress…</p>
      
            <div class="next-post">
        <div class="next-post-label">Next Post</div>
        <a href="/posts/probabilistic_thinking_for_simulations.html" class="next-post-card">
                    <div class="next-post-images" id="next-post-images"></div>
                    <div class="next-post-title">Probabilistic thinking for simulations</div>
        </a>
      </div>
          </main>
  </div>
  
    <script>
    // Parse and display next post images
    (function() {
      const imagesContainer = document.getElementById('next-post-images');
      if (imagesContainer) {
        try {
          const imagesJson = '["https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/probabilistic_thinking_for_simulations/probabilites-vs-trajectories.svg","https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/probabilistic_thinking_for_simulations/evaluate-probability-partition-region.svg"]';
          const images = JSON.parse(imagesJson);
          if (Array.isArray(images) && images.length > 0) {
            images.forEach(imagePath => {
              const img = document.createElement('img');
              img.src = imagePath;
              img.alt = 'Probabilistic thinking for simulations';
              imagesContainer.appendChild(img);
            });
          }
        } catch (e) {
          console.error('Error parsing next post images:', e);
        }
      }
    })();
  </script>
  
  <script>
    // Build series navigation for collections
    (function() {
      const seriesNav = document.getElementById('series-nav');
      if (!seriesNav) {
        return;
      }

      const seriesTag = seriesNav.dataset.seriesTag;
      if (!seriesTag || seriesTag === 'Loose Threads') {
        return;
      }

      const currentSlug = (window.location.pathname.split('/').pop() || '')
        .replace('.html', '')
        .trim();

      fetch('/posts.json')
        .then(response => response.json())
        .then(posts => {
          const seriesPosts = posts
            .filter(post => post.tag === seriesTag)
            .sort((a, b) => {
              const orderA = a.order !== undefined ? a.order : 999;
              const orderB = b.order !== undefined ? b.order : 999;
              if (orderA !== orderB) {
                return orderA - orderB;
              }
              return (a.title || '').localeCompare(b.title || '');
            });

          if (seriesPosts.length === 0) {
            seriesNav.style.display = 'none';
            return;
          }

          const currentIndex = seriesPosts.findIndex(post => {
            if (post.slug && post.slug === currentSlug) {
              return true;
            }
            if (post.url && currentSlug) {
              return post.url.endsWith(`/posts/.html`);
            }
            return false;
          });

          const toc = document.getElementById('series-toc');
          if (toc) {
            seriesPosts.forEach((post, index) => {
              const item = document.createElement('li');
              if (index === currentIndex) {
                item.classList.add('is-current');
              }
              const link = document.createElement('a');
              link.href = post.url;
              link.textContent = post.title || post.slug || 'Untitled';
              item.appendChild(link);
              toc.appendChild(item);
            });
          }
        })
        .catch(error => {
          console.error('Error loading posts for series navigation:', error);
        });
    })();
  </script>
</body>
</html>
