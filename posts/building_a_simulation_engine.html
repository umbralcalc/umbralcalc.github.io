<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="description" content="umbralcalculations - Visual explorations in computation, science and creative writing" />
  <meta name="keywords" content="computation, science, creative writing, simulation, data" />
  
  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="../assets/umbralcalculations-logo.svg">
  <link rel="icon" type="image/x-icon" href="../assets/favicon.ico">
  <link rel="apple-touch-icon" href="../assets/umbralcalculations-logo.svg">
  
  <title>Building a simulation engine</title>
  
  <!-- Fonts -->
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Merriweather:wght@300;400;700&family=Open+Sans:wght@300;400;600&display=swap');
  </style>
  
  <!-- Prism.js for syntax highlighting -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-vs.min.css" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-go.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-shell-session.min.js"></script>
  
  <!-- Custom CSS -->
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Open Sans', sans-serif;
      line-height: 1.6;
      color: #333;
      background: #fafafa;
      padding: 0;
      margin: 0;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 2rem;
      background: #fff;
      min-height: 100vh;
    }

    nav {
      margin-bottom: 3rem;
      padding-bottom: 1.5rem;
      border-bottom: 2px solid #e0e0e0;
      white-space: nowrap;
    }

    nav a {
      color: #2c3e50;
      text-decoration: none;
      font-weight: 600;
      margin-right: 2rem;
      transition: color 0.3s;
      font-size: 1.1rem;
      display: inline-block;
    }

    nav a:hover {
      color: #b0447aff;
      text-decoration: none;
    }

    /* Typography */
    h1, h2, h3, h4, h5, h6 {
      font-family: 'Merriweather', serif;
      color: #1a1a1a;
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      line-height: 1.3;
    }

    h1 {
      font-size: 2rem;
      color: #1a1a1a;
      margin-bottom: 0.5rem;
      border-bottom: 3px solid #2c3e50;
      padding-bottom: 0.3rem;
      margin-top: 0;
    }

    h2 {
      font-size: 1.8rem;
      color: #2c3e50;
      margin-top: 2rem;
      margin-bottom: 0.75rem;
      border-bottom: 2px solid #3c78d8ff;
      padding-bottom: 0.3rem;
    }

    h3 {
      font-size: 1.4rem;
      color: #2c3e50;
      margin-top: 1.5rem;
      margin-bottom: 0.5rem;
      font-weight: 600;
    }

    h4 {
      font-size: 1.2rem;
      color: #2c3e50;
      margin-top: 1.2rem;
      margin-bottom: 0.5rem;
      font-weight: 600;
    }

    h5, h6 {
      font-size: 1.1rem;
      color: #2c3e50;
      margin-top: 1rem;
      margin-bottom: 0.5rem;
      font-weight: 600;
    }

    p {
      margin-bottom: 1rem;
      color: #333;
      line-height: 1.7;
    }

    a {
      color: #3c78d8ff;
      text-decoration: none;
      transition: color 0.2s ease;
    }

    a:hover {
      color: #3c78d8ff;
      text-decoration: underline;
    }

    hr {
      border: none;
      border-top: 1px solid #ddd;
      margin: 2rem 0;
    }

    /* Code blocks */
    pre {
      background-color: #1e1e1e;
      color: #d4d4d4;
      padding: 1.5rem;
      border-radius: 0;
      overflow-x: auto;
      margin: 1.5rem 0;
      font-size: 0.875rem;
      line-height: 1.5;
      border: 1px solid #e0e0e0;
    }

    code {
      background-color: #f1f5f9;
      color: #333;
      padding: 0.125rem 0.375rem;
      border-radius: 0;
      font-size: 0.875rem;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'Courier New', monospace;
    }

    pre code {
      background-color: transparent;
      color: inherit;
      padding: 0;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'Courier New', monospace;
    }

    /* Lists */
    ul, ol {
      margin-bottom: 1rem;
      margin-left: 1.5rem;
    }

    li {
      margin-bottom: 0.5rem;
      color: #333;
      line-height: 1.6;
    }

    /* Tables */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1.5rem 0;
      background-color: #fff;
      border-radius: 0;
      overflow: hidden;
    }

    th, td {
      padding: 0.75rem 1rem;
      text-align: left;
      border-bottom: 1px solid #e0e0e0;
    }

    th {
      background-color: #f8f9fa;
      font-weight: 600;
      color: #2c3e50;
    }

    /* Blockquotes */
    blockquote {
      border-left: 4px solid #3c78d8ff;
      padding-left: 1rem;
      margin: 1.5rem 0;
      color: #555;
      font-style: italic;
    }

    /* Images */
    img {
      max-width: 100%;
      height: auto;
      border-radius: 0;
      margin: 1.5rem 0;
    }

    /* Math */
    .math {
      overflow-x: auto;
      overflow-y: hidden;
    }

    /* Responsive design */
    @media (max-width: 768px) {
      .container {
        padding: 1.5rem;
      }

      h1 {
        font-size: 1.8rem;
      }

      h2 {
        font-size: 1.5rem;
      }

      nav a {
        margin-right: 1.5rem;
        font-size: 1rem;
      }
      
      .series-hero {
        flex-direction: column;
        align-items: flex-start;
      }

      .series-cover {
        width: 100%;
        align-self: flex-start;
      }

      .post-images img {
        height: 96px;
      }
    }

    /* Series navigation */
    .series-nav {
      margin: 1.5rem 0 2.5rem;
      padding: 1.5rem;
      border: 1px solid #e0e0e0;
      background: #fafafa;
    }

    .series-eyebrow {
      font-size: 0.75rem;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      margin-bottom: 0.4rem;
    }

    .series-title {
      font-family: 'Merriweather', serif;
      font-size: 1.5rem;
      color: #2c3e50;
      margin: 0;
    }

    .series-hero {
      display: flex;
      align-items: center;
      gap: 1.5rem;
      margin: 0.75rem 0 1.2rem;
    }

    .series-cover {
      display: block;
      width: 20%;
      max-width: 520px;
      margin: 0;
      border: 1px solid #e0e0e0;
      background: #fff;
    }
    
    .series-blurb {
      flex: 1;
      margin: 0 0 0 20px;
      color: #888;
      font-size: 0.9rem;
      font-style: italic;
      line-height: 1.6;
      max-width: 400px;
    }

    /* Responsive design */
    @media (max-width: 768px) {
      .series-blurb {
        margin: 0 0 0 0;
      }
    }

    .series-toc-title {
      margin-top: 0.9rem;
      font-size: 1rem;
      color: #2c3e50;
      font-weight: 600;
    }

    .series-toc {
      margin: 0.4rem 0 0 1.2rem;
    }

    .series-toc li {
      margin-bottom: 0.4rem;
    }

    .series-toc a {
      color: #2c3e50;
    }

    .series-toc .is-current a {
      color: #3c78d8ff;
      font-weight: 600;
    }

    /* Next post card */
    .next-post {
      margin-top: 3rem;
      padding-top: 2rem;
      border-top: 1px solid #e0e0e0;
    }
    
    .next-post-label {
      font-size: 0.9rem;
      color: #888;
      margin-bottom: 1rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .next-post-card {
      display: block;
      text-decoration: none;
      color: inherit;
      padding: 1.5rem;
      border: 1px solid #e0e0e0;
      border-radius: 0;
      transition: all 0.3s ease;
      position: relative;
    }
    
    .next-post-card:hover {
      border-color: #3c78d8ff;
      box-shadow: 0 2px 8px rgba(52, 152, 219, 0.1);
      transform: translateY(-2px);
    }
    
    .next-post-card::after {
      content: "→";
      position: absolute;
      right: 1.5rem;
      top: 50%;
      transform: translateY(-50%);
      font-size: 1.5rem;
      color: #3c78d8ff;
      transition: transform 0.3s ease;
      font-weight: bold;
    }
    
    .next-post-card:hover::after {
      transform: translateY(-50%) translateX(5px);
    }
    
    .next-post-images {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    
    .next-post-images img {
      height: 120px;
      width: auto;
      border-radius: 0;
      display: block;
    }

    @media (max-width: 768px) {
      .next-post-images img {
        height: 80px;
      }
    }
    
    .next-post-title {
      font-family: 'Merriweather', serif;
      font-size: 1.5rem;
      color: #2c3e50;
      margin: 0;
      padding-right: 2rem;
    }
    
    .next-post-card:hover .next-post-title {
      color: #3c78d8ff;
    }
    
    /* Print styles */
    @media print {
      body {
        background: #fff;
      }
      
      .container {
        max-width: 100%;
        padding: 0;
      }
      
      .next-post {
        display: none;
      }

      .series-nav {
        display: none;
      }
    }
    
  </style>

    
    
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
  <div class="container">
    <nav>
      <a href="../index.html">Home</a>
      <a href="https://github.com/umbralcalc">GitHub</a>
      <a href="../cv.html">CV</a>
    </nav>

        <section class="series-nav" id="series-nav" data-series-tag="Simulating Real-World Systems as a Programmer" data-series-order="3">
      <div class="series-hero">
                <img class="series-cover" id="series-cover" src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/simulating-real-world-systems-as-a-programmer-cover.svg" alt="Simulating Real-World Systems as a Programmer cover" onerror="this.style.display='none'" />
                        <p class="series-blurb">A collection of posts on the foundations and patterns for building simulations of the real world. Written especially for programmers and non-technical readers wanting to learn the fundamentals. All written material and non-interactive diagrams were human-generated, where some interactive elements were programmed using generative AI tools.</p>
              </div>
      <div class="series-eyebrow">Collection</div>
      <h2 class="series-title">Simulating Real-World Systems as a Programmer</h2>
      <ol class="series-toc" id="series-toc"></ol>
    </section>
    
    <main>
      <h1 id="building-a-simulation-engine">Building a simulation engine</h1>
      <div style="height:0.75em;">

      </div>
      <h2 id="introducing-the-stochadex-project">Introducing the stochadex project</h2>
      <p>The building blocks of simulations that we have discussed can now be pieced together to form a complete simulation engine.</p>
      <p>The <a href="https://umbralcalc.github.io/stochadex">stochadex project</a> is an actual simulation engine written in Go which is based on these basic conceptual building blocks.</p>
      <p>Armed with the fundamentals, we can now describe how this simulation engine was built in specific detail, supported by the appropriate system diagrams.</p>
      <h2 id="interfaces-and-data-types">Interfaces and data types</h2>
      <p>The fundamental data types in the stochadex simulation engine are Go types which can be configured as <code>Settings</code> (pure data) or <code>Implementations</code> (code which implements the provided interfaces).</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/building_a_simulation_engine/stochadex-data-types.svg" />
      </center>
      <p>For example, we have the <code>Iteration</code> interface, which is based directly on the State Partition Iteration we discussed in the previous post.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/building_a_simulation_engine/fundamental-loop-code.svg" />
      </center>
      <p>The <code>Iteration</code> interface can be used to implement any simulation in practice. To illustrate this point, we can show how the internal logic may be implemented to recreate some well-known stochastic processes.</p>
      <p>For example, the <a href="https://en.wikipedia.org/wiki/Wiener_process">Wiener process</a> has some very simple logic.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/building_a_simulation_engine/wiener-process.svg" />
      </center>
      <div id="wiener-demo" style="margin:0.5em 0;padding:1em;background:#ffffff;border:1px solid #2c3e50;border-radius:6px;">
        <div style="font-weight:600;color:#2c3e50;margin-bottom:0.35em;padding:0 0.75em;">Wiener process sample path</div>
        <svg id="wiener-svg" width="100%" height="170" viewBox="0 0 320 170" role="img" aria-label="Wiener process sample path"></svg>
      </div>
      <div style="display:flex;flex-wrap:wrap;gap:0.75em;align-items:center;justify-content:flex-start;margin-top:0.6em;margin-bottom:1em;">
        <button id="wiener-btn" type="button" style="cursor:pointer;border:1px solid #3c78d8;background:#3c78d8;color:#ffffff;padding:0.4em 0.8em;border-radius:6px;font-size:1rem;">
          New sample path
        </button>
      </div>
      <script>
      (() => {
        const svg = document.getElementById("wiener-svg");
        const btn = document.getElementById("wiener-btn");
        if (!svg || !btn) return;

        const width = 320;
        const height = 170;
        const pad = 18;
        const steps = 80;

        const randn = () => {
          let u = 0;
          let v = 0;
          while (u === 0) u = Math.random();
          while (v === 0) v = Math.random();
          return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
        };

        const createSvgEl = (name, attrs = {}) => {
          const el = document.createElementNS("http://www.w3.org/2000/svg", name);
          Object.entries(attrs).forEach(([key, value]) => el.setAttribute(key, value));
          return el;
        };

        const render = () => {
          const values = [0];
          for (let i = 1; i <= steps; i += 1) {
            values.push(values[i - 1] + randn() * Math.sqrt(1 / steps));
          }
          const minVal = Math.min(...values);
          const maxVal = Math.max(...values);
          const range = maxVal - minVal || 1;

          svg.innerHTML = "";
          svg.appendChild(createSvgEl("line", {
            x1: pad,
            y1: height - pad,
            x2: width - pad,
            y2: height - pad,
            stroke: "#2c3e50",
            "stroke-width": "1",
          }));

          const points = values.map((value, idx) => {
            const x = pad + (idx / steps) * (width - 2 * pad);
            const y = height - pad - ((value - minVal) / range) * (height - 2 * pad);
            return { x, y };
          });
          const path = points.map((point, idx) => `${idx === 0 ? "M" : "L"}${point.x},${point.y}`).join(" ");
          svg.appendChild(createSvgEl("path", {
            d: path,
            fill: "none",
            stroke: "#3c78d8",
            "stroke-width": "2",
          }));
        };

        btn.addEventListener("click", render);
        render();
      })();
      </script>
      <p>It is well-known (especially by those in finance) that <a href="https://en.wikipedia.org/wiki/It%C3%B4%27s_lemma">Itô’s lemma</a> can be used to adapt the model formulae for a Wiener process after a mathematical function (a.k.a. transformation) has been applied to it.</p>
      <p>We can demonstrate that the <code>Iteration</code> interface can support this kind of transformation as well, through some more complicated logic.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/building_a_simulation_engine/ito-lemma.svg" />
      </center>
      <div id="ito-demo" style="margin:0.5em 0;padding:1em;background:#ffffff;border:1px solid #2c3e50;border-radius:6px;">
        <div style="font-weight:600;color:#2c3e50;margin-bottom:0.35em;padding:0 0.75em;">Itô transform of a Wiener path</div>
        <svg id="ito-svg" width="100%" height="170" viewBox="0 0 320 170" role="img" aria-label="Ito transform example"></svg>
        <div style="font-size:1rem;color:#2c3e50;margin-top:0.35em;padding:0 0.75em;">Blue is the base path; pink is f(x)=x².</div>
      </div>
      <div style="display:flex;flex-wrap:wrap;gap:0.75em;align-items:center;justify-content:flex-start;margin-top:0.6em;margin-bottom:1em;">
        <button id="ito-btn" type="button" style="cursor:pointer;border:1px solid #3c78d8;background:#3c78d8;color:#ffffff;padding:0.4em 0.8em;border-radius:6px;font-size:1rem;">
          New transform
        </button>
      </div>
      <script>
      (() => {
        const svg = document.getElementById("ito-svg");
        const btn = document.getElementById("ito-btn");
        if (!svg || !btn) return;

        const width = 320;
        const height = 170;
        const pad = 18;
        const steps = 80;

        const randn = () => {
          let u = 0;
          let v = 0;
          while (u === 0) u = Math.random();
          while (v === 0) v = Math.random();
          return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
        };

        const createSvgEl = (name, attrs = {}) => {
          const el = document.createElementNS("http://www.w3.org/2000/svg", name);
          Object.entries(attrs).forEach(([key, value]) => el.setAttribute(key, value));
          return el;
        };

        const render = () => {
          const values = [0];
          for (let i = 1; i <= steps; i += 1) {
            values.push(values[i - 1] + randn() * Math.sqrt(1 / steps));
          }
          const transformed = values.map((value) => value * value);
          const minVal = Math.min(...values, ...transformed);
          const maxVal = Math.max(...values, ...transformed);
          const range = maxVal - minVal || 1;

          svg.innerHTML = "";
          svg.appendChild(createSvgEl("line", {
            x1: pad,
            y1: height - pad,
            x2: width - pad,
            y2: height - pad,
            stroke: "#2c3e50",
            "stroke-width": "1",
          }));

          const mapPoints = (series) => series.map((value, idx) => {
            const x = pad + (idx / steps) * (width - 2 * pad);
            const y = height - pad - ((value - minVal) / range) * (height - 2 * pad);
            return { x, y };
          });

          const drawLine = (points, color, dash) => {
            const path = points.map((point, idx) => `${idx === 0 ? "M" : "L"}${point.x},${point.y}`).join(" ");
            svg.appendChild(createSvgEl("path", {
              d: path,
              fill: "none",
              stroke: color,
              "stroke-width": "2",
              "stroke-dasharray": dash || "none",
            }));
          };

          drawLine(mapPoints(values), "#3c78d8");
          drawLine(mapPoints(transformed), "#b0447a", "4 3");
        };

        btn.addEventListener("click", render);
        render();
      })();
      </script>
      <p>What about event-based processes?</p>
      <p>The Time-Inhomogeneous <a href="https://en.wikipedia.org/wiki/Poisson_point_process">Poisson process</a>, is an example of an event-based process which counts the cumulative number of events in Time, while its event rate varies.</p>
      <p>The <code>Iteration</code> interface can support this too.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/building_a_simulation_engine/inhomogeneous-poisson.svg" />
      </center>
      <div id="inhomogeneous-poisson-demo" style="margin:0.5em 0;padding:1em;background:#ffffff;border:1px solid #2c3e50;border-radius:6px;">
        <div style="font-weight:600;color:#2c3e50;margin-bottom:0.35em;padding:0 0.75em;">Inhomogeneous Poisson events</div>
        <svg id="inhomogeneous-poisson-svg" width="100%" height="170" viewBox="0 0 320 170" role="img" aria-label="Inhomogeneous Poisson process"></svg>
        <div style="font-size:1rem;color:#2c3e50;margin-top:0.35em;padding:0 0.75em;">Event ticks cluster where the rate curve is high.</div>
      </div>
      <div style="display:flex;flex-wrap:wrap;gap:0.75em;align-items:center;justify-content:flex-start;margin-top:0.6em;margin-bottom:1em;">
        <button id="inhomogeneous-poisson-btn" type="button" style="cursor:pointer;border:1px solid #3c78d8;background:#3c78d8;color:#ffffff;padding:0.4em 0.8em;border-radius:6px;font-size:1rem;">
          New event draw
        </button>
      </div>
      <script>
      (() => {
        const svg = document.getElementById("inhomogeneous-poisson-svg");
        const btn = document.getElementById("inhomogeneous-poisson-btn");
        if (!svg || !btn) return;

        const width = 320;
        const height = 170;
        const pad = 18;
        const steps = 120;

        const createSvgEl = (name, attrs = {}) => {
          const el = document.createElementNS("http://www.w3.org/2000/svg", name);
          Object.entries(attrs).forEach(([key, value]) => el.setAttribute(key, value));
          return el;
        };

        const render = () => {
          svg.innerHTML = "";
          const rates = [];
          for (let i = 0; i <= steps; i += 1) {
            const t = i / steps;
            const rate = 0.6 + 0.8 * Math.sin(2 * Math.PI * t) + 0.4 * Math.sin(6 * Math.PI * t);
            rates.push(Math.max(0.1, rate));
          }
          const maxRate = Math.max(...rates);

          svg.appendChild(createSvgEl("line", {
            x1: pad,
            y1: height - pad,
            x2: width - pad,
            y2: height - pad,
            stroke: "#2c3e50",
            "stroke-width": "1",
          }));

          const ratePoints = rates.map((rate, idx) => {
            const x = pad + (idx / steps) * (width - 2 * pad);
            const y = height - pad - (rate / maxRate) * (height - 2 * pad);
            return { x, y };
          });
          const path = ratePoints.map((point, idx) => `${idx === 0 ? "M" : "L"}${point.x},${point.y}`).join(" ");
          svg.appendChild(createSvgEl("path", {
            d: path,
            fill: "none",
            stroke: "#b0447a",
            "stroke-width": "2",
          }));

          const events = [];
          for (let i = 0; i <= steps; i += 1) {
            const t = i / steps;
            const rate = rates[i];
            const p = (rate / maxRate) * 0.18;
            if (Math.random() < p) {
              events.push(t);
            }
          }
          events.forEach((t) => {
            const x = pad + t * (width - 2 * pad);
            svg.appendChild(createSvgEl("line", {
              x1: x,
              y1: height - pad,
              x2: x,
              y2: height - pad - 14,
              stroke: "#3c78d8",
              "stroke-width": "2",
            }));
          });
        };

        btn.addEventListener("click", render);
        render();
      })();
      </script>
      <p>Let’s give one more example.</p>
      <p>The <a href="https://en.wikipedia.org/wiki/Hawkes_process">Hawkes process</a> couples the history of events to the current event rate. One may therefore categorise this process as ‘non-Markovian’.</p>
      <p>This means that the Hawkes process needs a memory of the State Partition History in order to calculate its Next State Values. Based on everything we have already built and discussed, the <code>Iteration</code> interface obviously supports this quite easily.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/building_a_simulation_engine/hawkes-process.svg" />
      </center>
      <div id="hawkes-demo" style="margin:0.5em 0;padding:1em;background:#ffffff;border:1px solid #2c3e50;border-radius:6px;">
        <div style="font-weight:600;color:#2c3e50;margin-bottom:0.35em;padding:0 0.75em;">Hawkes process (self-exciting events)</div>
        <svg id="hawkes-svg" width="100%" height="170" viewBox="0 0 320 170" role="img" aria-label="Hawkes process"></svg>
        <div style="font-size:1rem;color:#2c3e50;margin-top:0.35em;padding:0 0.75em;">Events cluster because each event lifts the intensity.</div>
      </div>
      <div style="display:flex;flex-wrap:wrap;gap:0.75em;align-items:center;justify-content:flex-start;margin-top:0.6em;margin-bottom:1em;">
        <button id="hawkes-btn" type="button" style="cursor:pointer;border:1px solid #3c78d8;background:#3c78d8;color:#ffffff;padding:0.4em 0.8em;border-radius:6px;font-size:1rem;">
          New event draw
        </button>
      </div>
      <script>
      (() => {
        const svg = document.getElementById("hawkes-svg");
        const btn = document.getElementById("hawkes-btn");
        if (!svg || !btn) return;

        const width = 320;
        const height = 170;
        const pad = 18;
        const steps = 120;

        const createSvgEl = (name, attrs = {}) => {
          const el = document.createElementNS("http://www.w3.org/2000/svg", name);
          Object.entries(attrs).forEach(([key, value]) => el.setAttribute(key, value));
          return el;
        };

        const render = () => {
          svg.innerHTML = "";
          const baseRate = 0.2;
          const alpha = 0.8;
          const beta = 6;
          const events = [];
          const intensities = [];

          for (let i = 0; i <= steps; i += 1) {
            const t = i / steps;
            let intensity = baseRate;
            events.forEach((time) => {
              intensity += alpha * Math.exp(-beta * (t - time));
            });
            intensities.push(intensity);
            const p = intensity * 0.12;
            if (Math.random() < p) {
              events.push(t);
            }
          }

          const maxIntensity = Math.max(...intensities);
          svg.appendChild(createSvgEl("line", {
            x1: pad,
            y1: height - pad,
            x2: width - pad,
            y2: height - pad,
            stroke: "#2c3e50",
            "stroke-width": "1",
          }));

          const intensityPoints = intensities.map((value, idx) => {
            const x = pad + (idx / steps) * (width - 2 * pad);
            const y = height - pad - (value / maxIntensity) * (height - 2 * pad);
            return { x, y };
          });
          const path = intensityPoints.map((point, idx) => `${idx === 0 ? "M" : "L"}${point.x},${point.y}`).join(" ");
          svg.appendChild(createSvgEl("path", {
            d: path,
            fill: "none",
            stroke: "#b0447a",
            "stroke-width": "2",
          }));

          events.forEach((t) => {
            const x = pad + t * (width - 2 * pad);
            svg.appendChild(createSvgEl("line", {
              x1: x,
              y1: height - pad,
              x2: x,
              y2: height - pad - 14,
              stroke: "#3c78d8",
              "stroke-width": "2",
            }));
          });
        };

        btn.addEventListener("click", render);
        render();
      })();
      </script>
      <h2 id="serial-dependency-graphs-and-modularity">Serial dependency graphs and modularity</h2>
      <p>Multiple <code>Iteration</code>s can run within the stochadex for each step in Time. In order to construct serial dependency graphs between them, we can utilise upstream-downstream <code>Iteration</code> relationships.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/building_a_simulation_engine/stochadex-parallel-serial.svg" />
      </center>
      <p>Structuring groups of <code>Iteration</code>s in this way can increase modularity. For example, the Time-Inhomogeneous Poisson process can be implemented serially.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/building_a_simulation_engine/inhomo-poisson-parallel-serial.svg" />
      </center>
      <h2 id="simulation-loop-and-embedded-simulation-runs">Simulation loop and embedded simulation runs</h2>
      <p>The Simulation Run loop coordinates the serial relationships between <code>Iteration</code>s while maximising concurrency in execution of each <code>Iteration</code> per step in Time.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/building_a_simulation_engine/stochadex-loop.svg" />
      </center>
      <p>Given that this loop always runs for any stochadex simulation, it is sufficient to describe any simulation uniquely through the dependency diagram between its <code>Iteration</code>s.</p>
      <p>Having designed the Simulation Run loop, are now finally able to implement Embedded Simulation Runs.</p>
      <p>As a reminder; Embedded Simulation Runs are <code>Iteration</code>s which perform entire Simulation Runs from start to end for every Timestep. Their presence can make the diagrams a little more complex, but even more flexible.</p>
      <p>The <code>Iteration</code> interface can support these as well.</p>
      <center>
      <img src="https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/building_a_simulation_engine/embedded-simulations.svg" />
      </center>
      
            <div class="next-post">
        <div class="next-post-label">Next Post</div>
        <a href="/posts/probabilistic_thinking_for_simulations.html" class="next-post-card">
                    <div class="next-post-images" id="next-post-images"></div>
                    <div class="next-post-title">Probabilistic thinking for simulations</div>
        </a>
      </div>
          </main>
  </div>
  
    <script>
    // Parse and display next post images
    (function() {
      const imagesContainer = document.getElementById('next-post-images');
      if (imagesContainer) {
        try {
          const imagesJson = '["https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/probabilistic_thinking_for_simulations/probabilites-vs-trajectories.svg","https://pub-afdb1348ec964ca5b530aa758c0bdc56.r2.dev/assets/probabilistic_thinking_for_simulations/evaluate-probability-partition-region.svg"]';
          const images = JSON.parse(imagesJson);
          if (Array.isArray(images) && images.length > 0) {
            images.forEach(imagePath => {
              const img = document.createElement('img');
              img.src = imagePath;
              img.alt = 'Probabilistic thinking for simulations';
              imagesContainer.appendChild(img);
            });
          }
        } catch (e) {
          console.error('Error parsing next post images:', e);
        }
      }
    })();
  </script>
  
  <script>
    // Build series navigation for collections
    (function() {
      const seriesNav = document.getElementById('series-nav');
      if (!seriesNav) {
        return;
      }

      const seriesTag = seriesNav.dataset.seriesTag;
      if (!seriesTag || seriesTag === 'Loose Threads') {
        return;
      }

      const currentSlug = (window.location.pathname.split('/').pop() || '')
        .replace('.html', '')
        .trim();

      fetch('/posts.json')
        .then(response => response.json())
        .then(posts => {
          const seriesPosts = posts
            .filter(post => post.tag === seriesTag)
            .sort((a, b) => {
              const orderA = a.order !== undefined ? a.order : 999;
              const orderB = b.order !== undefined ? b.order : 999;
              if (orderA !== orderB) {
                return orderA - orderB;
              }
              return (a.title || '').localeCompare(b.title || '');
            });

          if (seriesPosts.length === 0) {
            seriesNav.style.display = 'none';
            return;
          }

          const currentIndex = seriesPosts.findIndex(post => {
            if (post.slug && post.slug === currentSlug) {
              return true;
            }
            if (post.url && currentSlug) {
              return post.url.endsWith(`/posts/.html`);
            }
            return false;
          });

          const toc = document.getElementById('series-toc');
          if (toc) {
            seriesPosts.forEach((post, index) => {
              const item = document.createElement('li');
              if (index === currentIndex) {
                item.classList.add('is-current');
              }
              const link = document.createElement('a');
              link.href = post.url;
              link.textContent = post.title || post.slug || 'Untitled';
              item.appendChild(link);
              toc.appendChild(item);
            });
          }
        })
        .catch(error => {
          console.error('Error loading posts for series navigation:', error);
        });
    })();
  </script>
</body>
</html>
